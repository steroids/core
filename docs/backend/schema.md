# Схемы (Scheme)

Схемы в Steroids - это нововведение, предназначенные для описания структуры данных. Чтобы понять их область применения,
начнем сразу с примера.

Допустим, у нас есть сущность пользователя `User` и есть два API метода:
    - `GET /users` Получение списка пользователей, где нужны только поля `id`, `name`
    - `GET /users/<id>` Получение детальной информации по пользователю, где помимо `id` и `name` нужны все остальные
    поля: `avatarImage`, `balance`, `firstName`, `lastName`, `userStatus`, `role`, `createTime`

Конечно, мы можем просто для каждого метода вызвать `$user->toFrontend(...)` и передать массив атрибутов, которые нам
необходимы. Но что, если таких методов не 2, а 20, где в выдаче участвует пользователь? Придется перечисления атрибутов
где-то хранить. В Steroids для них есть место - Схемы.

Для примера выше мы можем создать две схемы, одна из которых будет расширять другую:

```php
class UserSchema extends BaseSchema
{
    /**
     * @var User
     */
    public $model;

    public function fields()
    {
        return [
            'id',
            'name',
        ];
    }
}
```

```php
class UserDetailSchema extends UserSchema
{
    public function fields()
    {
        return [
            ...parent::fields(),
            'avatarImage',
            'balance',
            'firstName',
            'lastName',
            'userStatus' => 'model.status',
            'role',
            'createTime',
        ];
    }

    public function getAvatarImage()
    {
        return new ImageSchema(['model' => $this->model->avatar]);
    }

    public function getBalance()
    {
        return round($this->model->balance / 100, 2);
    }
}
```

Как видите, в схемах можно не только хранить набор атрибутов. В них можно создавать свои геттеры, в которых можно
форматировать данные или возвращать вложенные схемы. В примере выше мы приводим баланс из копеек к рублям, а для
аватара возвращаем схему `ImageSchema`, на вход которой отдаем модель из связи `avatar`.

Формат данных метода `fields()` аналогичен формату аналогичного метода моделей и описан в разделе
[Публичные поля и схемы](model_fields.md). Но есть и некоторые дополнения, о которых поговорим ниже.


## Приоритет выбора значения

При вызове метода схемы `toFrontend()` существует порядок, по которому проверяются места, откуда можно взять значение
поля:

- Если в схеме есть геттер с таким именем - то он будет вызван;
- Если в схеме есть `property` с таким именем, то будет взято его значение;
- В остальных случаях схема будет искать поле в моделе, переданной в `$model`.


## Прямое обращение к модели

В примере выше есть поле `userStatus`, которое необходимо взять из модели. В этом случае необходимо добавить префикс
`model.`, чтобы значение было напрямую взято из модели.


## Получение списка, метод `::toList()`

Если нам нужно выдать список моделей и для каждой применить схему, то можно воспользоваться статичным методом схемы
`::toList($models)`:

```php
    public function actionGetLastArticles()
    {
        $articles = Article::find()->limit(3)->order(['id' => SORT_DESC])->all();
        return ArticleSchema::toList($articles);
    }
```


## Контекстный пользователь

Бывают случаи, когда необходимо выдать данные относительно пользователя, который ее получает. Например, при получении
статьи, необходимо знать ставил ли пользователь ее в закладки или нет.

Как вариант - можно в схеме создать дополнительный геттер и получить пользователя из `Yii::$app->user->identity`, но
получение контекстного пользователя из глобального состояния - плохое решение. Поскольку схемы могут использоваться и
в консольном приложении, а там компонента `user` вообще нет. Поэтому старайтесь использовать получение контекстного
пользователя только в `web` контроллерах и экшенах.

А передать пользователя в схему можно при создании ее экземпляра:

```php
    public function actionGetArticle($id)
    {
        return new ArticleSchema([
            'model' => Article::findOrPanic(['id' => (int)$id]),
            'user' => Yii::$app->user->identity,
        ]);
    }
```

В таком случае схема будет выглядеть следующим образом:

```php
class ArticleSchema extends BaseSchema
{
    /**
     * @var Article
     */
    public $model;

    /**
     * @var User
     */
    public $user;
    
    public function fields()
    {
        return [
            'id',
            'title',
            'isInUserBookmarks',
        ];
    }
    
    public function getIsInUserBookmarks()
    {
        return ArticleUserBookmark::find()
            ->where([
                'articleId' => $this->model->id,
                'userId' => $this->user->id,
            ])
            ->exits();
    }
}
```

Аналогично можно передавать любые другие параметры в схему, поскольку она унаследована от обычного `\yii\base\BaseObject`.
